

std::vector<std::string> Translate(const std::vector<std::string>& Inputs) {
    CURL* curl = curl_easy_init();
    std::vector<std::string> translated_responses;
    std::string raw_translated_responses;
    
    if (curl) {
        std::string translation_instructions = "Translate the name of each file/folder into English. Respond only with the translated name.";

        jason input_array;
        for (const auto& input : Inputs) {
            input_array.push_back({
                {"parts", {{
                    {"text", input}
                }}}
            });
        }

        jason payload = {
            {"system_instruction", {
                {"parts", {{
                    {"text", translation_instructions}
                }}}
            }},
            {"contents", input_array},
            {"generationConfig", {
                {"thinkingConfig", {
                    {"thinkingBudget", 0}
                }}
            }}
        };
        std::string payload_string = payload.dump();
        
        struct curl_slist *curl_headers = nullptr;
        curl_headers = curl_slist_append(curl_headers, "Content-Type: application/json");
        curl_headers = curl_slist_append(curl_headers, ("X-goog-api-key: " + GEMINI_API_KEY).c_str());
 
        const std::string GEMINI_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=";
        
        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, curl_headers);
        curl_easy_setopt(curl, CURLOPT_URL, GEMINI_URL.c_str());
        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, payload_string.c_str());
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallbackForCurl);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &raw_translated_responses);
        curl_easy_setopt(curl, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);
        
        CURLcode reponse_code = curl_easy_perform(curl);
        if (reponse_code != CURLE_OK) {
            std::cerr << "curl_easy_perform() failed: " << curl_easy_strerror(reponse_code) << "\n";
        }
        
        curl_slist_free_all(curl_headers);
        curl_easy_cleanup(curl);
    }
    
    std::cerr << "Raw Response:\n" << raw_translated_responses << '\n';
    
    try {
        auto json_response = jason::parse(raw_translated_responses);
        auto candidates = json_response["candidates"];
        for (const auto& candidate : candidates) {
            std::string translated_text = candidate["content"]["parts"][0]["text"];
            translated_text.erase(std::remove(translated_text.begin(), translated_text.end(), '\n'), translated_text.end());
            translated_responses.push_back(translated_text);
        }

        if (translated_responses.size() != Inputs.size()) {
            std::cerr << "Warning:  number of translated responses does not match the number of inputs\n";
        }
        return translated_responses;
    }
    catch (...) {
        std::cerr << "Translator function error parsing json response";
        return Inputs;
    }
}

void RunParallel(std::filesystem::path TargetPath, bool IsTestRun) {
    std::vector<std::filesystem::directory_entry> file_directories;
    std::vector<std::string> file_names;
    
    for (const auto& file : std::filesystem::directory_iterator(TargetPath)) {
        file_directories.push_back(file);
        file_names.push_back(file.path().stem().string());
    }

    std::vector<std::string> translated_names = Translate(file_names);
    if (IsTestRun) {
        std::cout << "\n  [Test Run]\n\n";
    }
    for (size_t i = 0; i < file_directories.size(); i++) {
        const auto& path = file_directories[i].path();
        std::string file_extension = path.extension().string();
        std::string new_name = translated_names[i] + file_extension;

        if (IsTestRun) {
            std::cout << "- Would rename \"" << path.filename().string() << "\" to \"" << new_name << "\"\n";
            return;
        }
        
        RenameFolder(path, new_name);
    }
}